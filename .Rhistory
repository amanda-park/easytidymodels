add_recipe(rec %>% step_rm(Date)) %>%
fit(train)
#Prophet with XGBoost Errors
prophet_boost_model <- prophet_boost(seasonality_daily = "auto",
trees = 100) %>%
set_engine("prophet_xgboost")
prophet_boost_model_workflow <- workflow() %>%
add_model(prophet_boost_model) %>%
add_recipe(rec) %>%
fit(train)
forecast_table <- modeltime_table(
arima_model,
prophet_model,
ets_model,
tbats_model,
nn_model,
stlm_ets_model,
stlm_arima_model,
glmnet_model_workflow,
prophet_boost_model_workflow
)
acc <- forecast_table %>%
modeltime_calibrate(test) %>%
modeltime_accuracy() %>%
arrange(mase)
order <- acc$.model_id
forecast_table <- forecast_table[order,]
crossValPlot <- forecast_table %>%
modeltime_calibrate(test) %>%
modeltime_forecast(actual_data = test) %>%
plot_modeltime_forecast()
fcastVals <- forecast_table %>%
modeltime_refit(df) %>%
modeltime_calibrate(df) %>%
modeltime_forecast(h = 7, actual_data = df)
fcast <- fcastVals %>%
plot_modeltime_forecast()
#Model ensembling
ensembleAvg <- forecast_table %>%
ensemble_average(type = "mean")
ensembleMed <- forecast_table %>%
ensemble_average(type = "median")
ensembleWeighted <- forecast_table[1:5,] %>%
ensemble_weighted(loadings = c(5, 4, 3, 2, 1),
scale_loadings = TRUE)
ensembleTable <- modeltime_table(
ensembleAvg,
ensembleMed,
ensembleWeighted
)
accEnsemble <- ensembleTable %>%
modeltime_calibrate(test) %>%
modeltime_accuracy()
fcastEnsembleVals <- ensembleTable %>%
modeltime_calibrate(df) %>%
modeltime_forecast(
new_data    = test,
actual_data = df
)
fcastEnsemblePlot <- fcastEnsembleVals %>%
plot_modeltime_forecast()
output <- list(
"accuracyTable" = acc,
"crossValPlot" = crossValPlot,
"forecastTable" = forecast_table,
"forecastPlot" = fcast,
"forecastValues" = fcastVals,
"accuracyEnsembleTable" = accEnsemble,
"forecastEnsemblePlot" = fcastEnsemblePlot,
"forecastEnsembleValues" = fcastEnsembleVals
)
return(output)
}
res <- modelTimeSeries()
res$forecastPlot
modelTimeSeries <- function(train = tr,
test = ts,
df = dts,
response = resp,
predictor = pred,
folds = cvFolds) {
#Automate formula
formulaBase <- as.formula(paste(response, ".", sep="~"))
#Recipe-free models
arima_model <- arima_reg() %>%
set_engine("auto_arima") %>%
fit(formulaBase, data = train)
prophet_model <- prophet_reg() %>%
set_engine("prophet") %>%
fit(formulaBase, data = train)
ets_model <- exp_smoothing() %>%
set_engine("ets") %>%
fit(formulaBase, data = train)
tbats_model <- seasonal_reg() %>%
set_engine("tbats") %>%
fit(formulaBase, data = train)
nn_model <- nnetar_reg() %>%
set_engine("nnetar") %>%
fit(formulaBase, data = train)
stlm_ets_model <- seasonal_reg() %>%
set_engine("stlm_ets") %>%
fit(formulaBase, data = train)
stlm_arima_model <- seasonal_reg() %>%
set_engine("stlm_arima") %>%
fit(formulaBase, data = train)
#Models with recipes included
rec <- recipes::recipe(Value ~ Date, train) %>%
timetk::step_timeseries_signature(Date) %>%
recipes::step_rm(contains("am.pm"), contains("hour"), contains("minute"),
contains("second"), contains("xts")) %>%
recipes::step_dummy(all_nominal()) %>%
prep()
#Elastic Net
glmnet_model <- linear_reg(penalty = 0.01, mixture = 0.67) %>%
set_engine("glmnet")
glmnet_model_workflow <- workflow() %>%
add_model(glmnet_model) %>%
add_recipe(rec %>% step_rm(Date)) %>%
fit(train)
#Prophet with XGBoost Errors
prophet_boost_model <- prophet_boost(seasonality_daily = "auto",
trees = 100) %>%
set_engine("prophet_xgboost")
prophet_boost_model_workflow <- workflow() %>%
add_model(prophet_boost_model) %>%
add_recipe(rec) %>%
fit(train)
#Auto ARIMA with XGBoost Errors
auto_arima_boost_model <- arima_boost() %>%
set_engine("arima_boost")
arima_boost_model_workflow <- workflow() %>%
add_model(auto_arima_boost_model) %>%
add_recipe(rec) %>%
fit(train)
forecast_table <- modeltime_table(
arima_model,
prophet_model,
ets_model,
tbats_model,
nn_model,
stlm_ets_model,
stlm_arima_model,
glmnet_model_workflow,
prophet_boost_model_workflow,
arima_boost_model_workflow
)
acc <- forecast_table %>%
modeltime_calibrate(test) %>%
modeltime_accuracy() %>%
arrange(mase)
order <- acc$.model_id
forecast_table <- forecast_table[order,]
crossValPlot <- forecast_table %>%
modeltime_calibrate(test) %>%
modeltime_forecast(actual_data = test) %>%
plot_modeltime_forecast()
fcastVals <- forecast_table %>%
modeltime_refit(df) %>%
modeltime_calibrate(df) %>%
modeltime_forecast(h = 7, actual_data = df)
fcast <- fcastVals %>%
plot_modeltime_forecast()
#Model ensembling
ensembleAvg <- forecast_table %>%
ensemble_average(type = "mean")
ensembleMed <- forecast_table %>%
ensemble_average(type = "median")
ensembleWeighted <- forecast_table[1:5,] %>%
ensemble_weighted(loadings = c(5, 4, 3, 2, 1),
scale_loadings = TRUE)
ensembleTable <- modeltime_table(
ensembleAvg,
ensembleMed,
ensembleWeighted
)
accEnsemble <- ensembleTable %>%
modeltime_calibrate(test) %>%
modeltime_accuracy()
fcastEnsembleVals <- ensembleTable %>%
modeltime_calibrate(df) %>%
modeltime_forecast(
new_data    = test,
actual_data = df
)
fcastEnsemblePlot <- fcastEnsembleVals %>%
plot_modeltime_forecast()
output <- list(
"accuracyTable" = acc,
"crossValPlot" = crossValPlot,
"forecastTable" = forecast_table,
"forecastPlot" = fcast,
"forecastValues" = fcastVals,
"accuracyEnsembleTable" = accEnsemble,
"forecastEnsemblePlot" = fcastEnsemblePlot,
"forecastEnsembleValues" = fcastEnsembleVals
)
return(output)
}
res <- modelTimeSeries()
modelTimeSeries <- function(train = tr,
test = ts,
df = dts,
response = resp,
predictor = pred,
folds = cvFolds) {
#Automate formula
formulaBase <- as.formula(paste(response, ".", sep="~"))
#Recipe-free models
arima_model <- arima_reg() %>%
set_engine("auto_arima") %>%
fit(formulaBase, data = train)
prophet_model <- prophet_reg() %>%
set_engine("prophet") %>%
fit(formulaBase, data = train)
ets_model <- exp_smoothing() %>%
set_engine("ets") %>%
fit(formulaBase, data = train)
tbats_model <- seasonal_reg() %>%
set_engine("tbats") %>%
fit(formulaBase, data = train)
nn_model <- nnetar_reg() %>%
set_engine("nnetar") %>%
fit(formulaBase, data = train)
stlm_ets_model <- seasonal_reg() %>%
set_engine("stlm_ets") %>%
fit(formulaBase, data = train)
stlm_arima_model <- seasonal_reg() %>%
set_engine("stlm_arima") %>%
fit(formulaBase, data = train)
#Models with recipes included
rec <- recipes::recipe(Value ~ Date, train) %>%
timetk::step_timeseries_signature(Date) %>%
recipes::step_rm(contains("am.pm"), contains("hour"), contains("minute"),
contains("second"), contains("xts")) %>%
recipes::step_dummy(all_nominal()) %>%
prep()
#Elastic Net
glmnet_model <- linear_reg(penalty = 0.01, mixture = 0.67) %>%
set_engine("glmnet")
glmnet_model_workflow <- workflow() %>%
add_model(glmnet_model) %>%
add_recipe(rec %>% step_rm(Date)) %>%
fit(train)
#Prophet with XGBoost Errors
prophet_boost_model <- prophet_boost(seasonality_daily = "auto",
trees = 100) %>%
set_engine("prophet_xgboost")
prophet_boost_model_workflow <- workflow() %>%
add_model(prophet_boost_model) %>%
add_recipe(rec) %>%
fit(train)
#Auto ARIMA with XGBoost Errors
auto_arima_boost_model <- arima_boost() %>%
set_engine("auto_arima_xgboost")
arima_boost_model_workflow <- workflow() %>%
add_model(auto_arima_boost_model) %>%
add_recipe(rec) %>%
fit(train)
forecast_table <- modeltime_table(
arima_model,
prophet_model,
ets_model,
tbats_model,
nn_model,
stlm_ets_model,
stlm_arima_model,
glmnet_model_workflow,
prophet_boost_model_workflow,
arima_boost_model_workflow
)
acc <- forecast_table %>%
modeltime_calibrate(test) %>%
modeltime_accuracy() %>%
arrange(mase)
order <- acc$.model_id
forecast_table <- forecast_table[order,]
crossValPlot <- forecast_table %>%
modeltime_calibrate(test) %>%
modeltime_forecast(actual_data = test) %>%
plot_modeltime_forecast()
fcastVals <- forecast_table %>%
modeltime_refit(df) %>%
modeltime_calibrate(df) %>%
modeltime_forecast(h = 7, actual_data = df)
fcast <- fcastVals %>%
plot_modeltime_forecast()
#Model ensembling
ensembleAvg <- forecast_table %>%
ensemble_average(type = "mean")
ensembleMed <- forecast_table %>%
ensemble_average(type = "median")
ensembleWeighted <- forecast_table[1:5,] %>%
ensemble_weighted(loadings = c(5, 4, 3, 2, 1),
scale_loadings = TRUE)
ensembleTable <- modeltime_table(
ensembleAvg,
ensembleMed,
ensembleWeighted
)
accEnsemble <- ensembleTable %>%
modeltime_calibrate(test) %>%
modeltime_accuracy()
fcastEnsembleVals <- ensembleTable %>%
modeltime_calibrate(df) %>%
modeltime_forecast(
new_data    = test,
actual_data = df
)
fcastEnsemblePlot <- fcastEnsembleVals %>%
plot_modeltime_forecast()
output <- list(
"accuracyTable" = acc,
"crossValPlot" = crossValPlot,
"forecastTable" = forecast_table,
"forecastPlot" = fcast,
"forecastValues" = fcastVals,
"accuracyEnsembleTable" = accEnsemble,
"forecastEnsemblePlot" = fcastEnsemblePlot,
"forecastEnsembleValues" = fcastEnsembleVals
)
return(output)
}
res <- modelTimeSeries()
res$forecastPlot
table <- res$forecastTable
table
str(df)
dts
?time_series_cv
resamples <- time_series_cv(
data        = tr,
assess      = 10,
initial     = 80,
skip        = 10,
slice_limit = 4
)
resamples <- time_series_cv(
data        = tr,
assess      = floor(nrow(tr) / 10),
initial     = nrow(tr),
skip        = floor(nrow(tr) / 10),
slice_limit = 4
)
nrow(tr)
resamples <- time_series_cv(
data        = tr,
assess      = floor(nrow(tr) / 10),
initial     = floor(nrow(tr) / 1.5),
skip        = floor(nrow(tr) / 10),
slice_limit = 4
)
resamples
resamples <- time_series_cv(
data        = tr,
assess      = floor(nrow(tr) / 10),
initial     = floor(nrow(tr) / 1.5),
skip        = floor(nrow(tr) / 10),
slice_limit = 5
)
resamples
# Begin with a Cross Validation Strategy
resamples %>%
tk_time_series_cv_plan() %>%
plot_time_series_cv_plan(Date, Value, .facet_ncol = 2, .interactive = FALSE)
resamples <- time_series_cv(
data        = tr,
assess      = floor(nrow(tr) / 10),
initial     = floor(nrow(tr) / 4),
skip        = floor(nrow(tr) / 10),
slice_limit = 5
)
# Begin with a Cross Validation Strategy
resamples %>%
tk_time_series_cv_plan() %>%
plot_time_series_cv_plan(Date, Value, .facet_ncol = 2, .interactive = FALSE)
table %>%
modeltime_fit_resamples(
resamples = resamples,
control   = control_resamples(verbose = FALSE)
)
resamplesFitted <- table %>%
modeltime_fit_resamples(
resamples = resamples,
control   = control_resamples(verbose = FALSE)
)
resamplesPlot <- resamplesFitted %>%
plot_modeltime_resamples(
.point_size  = 3,
.point_alpha = 0.8,
.interactive = FALSE
)
resamplesPlot
resamplesPlot
resamplesTable <- resamplesFitted %>%
modeltime_resample_accuracy(summary_fns = mean) %>%
table_modeltime_accuracy(.interactive = FALSE)
resamplesTable
resampleTimeSeries <- function(train = tr,
table = res$forecastTable) {
resamples <- time_series_cv(
data        = tr,
assess      = floor(nrow(tr) / 10),
initial     = floor(nrow(tr) / 4),
skip        = floor(nrow(tr) / 10),
slice_limit = 5
)
# Begin with a Cross Validation Strategy
resampleSplits <- resamples %>%
tk_time_series_cv_plan() %>%
plot_time_series_cv_plan(Date, Value, .facet_ncol = 2, .interactive = FALSE)
resamplesFitted <- table %>%
modeltime_fit_resamples(
resamples = resamples,
control   = control_resamples(verbose = FALSE)
)
resamplesPlot <- resamplesFitted %>%
plot_modeltime_resamples(
.point_size  = 3,
.point_alpha = 0.8,
.interactive = FALSE
)
resamplesTable <- resamplesFitted %>%
modeltime_resample_accuracy(summary_fns = mean) %>%
table_modeltime_accuracy(.interactive = FALSE)
output <- list(
"table" = resamplesTable,
"plot" = resamplesPlot,
"fit" = resamplesFitted,
"splits" = resampleSplits
)
return(output)
}
resample <- resampleTimeSeries()
output <- modelTimeSeries()
resample <- resampleTimeSeries()
resample$fit
resample$table
resample$plot
resample$splits
require(devtools)
use_r("resampleTimeSeries")
?time_series_cv
?tk_time_series_cv_plan
?plot_time_series_cv_plan
?control_resamples
?modeltime_fit_resamples
?plot_modeltime_resamples
?table_modeltime_accuracy
str(res$forecastTable)
res$forecastTable
devtools::check()
devtools::check()
?set_engine
?add_model
?prophet_boost
devtools::check()
devtools::check()
df$Date <- seq(as.Date("2020-01-01"), as.Date("2020-04-09"), by="days")
install()
detach("package:rlang", unload = TRUE)
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
knitr::opts_chunk$set(echo = TRUE)
#Set working directory and load functions in
#setwd("C:/Users/youid/Dropbox/Professional")
source("TidyModelsFunctions.R")
require(pacman)
p_load(
tidymodels,
vip,
fastshap,
doParallel,
xgboost,
glmnet,
earth,
patchwork,
margins,
ggfortify,
modeltime,
timetk,
modeltime.ensemble,
modeltime.resample,
update = FALSE
)
set.seed(24)
d <- data.frame(a = c(rep(1, 50), rep(0, 50)),
b = rnorm(100),
c = rnorm(100),
da = c(rnorm(55), rnorm(45, 5)),
e = c(rnorm(30, 1), rnorm(70, 5)),
f = c(rnorm(40, 0), rnorm(60, 4)),
g = c(rep(1, 20), rep(2, 40), rep(3, 40))
)
d$a <- as.factor(d$a)
d$g <- as.factor(d$g)
d$Date <- seq(as.Date("2020-01-01"), as.Date("2020-04-09"), by="days")
dts <- d %>% select(b, Date) %>% set_names("Value", "Date")
resp <- "Value"
pred <- "Date"
splitDat <- trainTestSplit(data = dts,
splitAmt = .8,
timeDependent = TRUE,
responseVar = resp,
stratifyOnResponse = FALSE)
#Remove data sets from list
tr <- splitDat$datTrain
ts <- splitDat$datTest
init <- initialTimeSeriesEval()
output <- modelTimeSeries()
resample <- resampleTimeSeries()
resample$splits
